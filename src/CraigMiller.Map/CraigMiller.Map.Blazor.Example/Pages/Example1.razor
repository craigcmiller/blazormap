@page "/"
@using CraigMiller.Map.Core.Layers.Tiling
@using CraigMiller.Map.Core.Routes

<PageTitle>BlazorMap</PageTitle>

<nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">BlazorMap</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarText" aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarText">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item px-1">
                    <button class="btn btn-outline-dark" @onclick="ClearRoute">Clear Route</button>
                </li>
                <li class="nav-item px-1">
                    <button class="btn btn-outline-dark" @onclick="NorthToTop">North to Top</button>
                </li>
            </ul>
        </div>
    </div>
</nav>
<Map @ref="_map" Style="height:800px" CenterLatitude="0" CenterLongitude="0" />

<div class="row g-3 mt-1">
    <div class="col-6">
        <label class="form-label">Latitude</label>
        <input @bind-value="_animateLatText" type="text" class="form-control" placeholder="decimal latitude" aria-label="Latitude">
    </div>
    <div class="col-6">
        <label class="form-label">Longitude</label>
        <input @bind-value="_animateLonText" type="text" class="form-control" placeholder="decimal longitude" aria-label="Longitude">
    </div>
</div>
<div class="row g-3 mt-1">
    <div class="col">
        <button @onclick="() => CenterOn(true)" class="btn btn-primary">Animate Zoom To</button>
        <button @onclick="() => CenterOn(false)" class="btn btn-primary">Instant Center</button>
        <button @onclick="AnimateAlongRoute" class="btn btn-primary">Animate Route</button>
    </div>
</div>

<div class="row g-3 mt-1">
    <div class="col-6">
        <label class="form-label">Rotation degrees:</label>
        <input @bind-value="_rotationDegreesStr" type="text" class="form-control" placeholder="degrees">
    </div>
    <div class="col mt-auto">
        <button @onclick="Rotate" class="btn btn-primary">Rotate</button>
    </div>
</div>

@code {
    Map? _map;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            _map!.AddDebugLayers();
        }
    }

    string? _animateLatText = "50.83560181", _animateLonText = "-0.29722199";

    private void CenterOn(bool animate)
    {
        if (!double.TryParse(_animateLatText, out double lat) || !double.TryParse(_animateLonText, out double lon))
        {
            return;
        }

        AddRouteLayer(lat, lon);

        var centerLoc = new Location(lat, lon);

        var circleMarkerLayer = new CircleMarkerLayer
            {
                Locations = [ centerLoc ]
            };

        DurationAnimatedLayer<CircleMarkerLayer> animatedCircleMarker = CircleMarkerLayer.CreateAnimated(circleMarkerLayer, TimeSpan.FromSeconds(2), 8, 32);
        animatedCircleMarker.MaxRepetitions = 4;
        _map!.Engine.AddLayer(animatedCircleMarker);

        if (animate)
        {
            TimeSpan timespan = TimeSpan.FromSeconds(5);

            var pan = new PanToLocationAnimation(new Location(lat, lon), timespan, RateFunctions.AccelerateDecelerate);
            var zoom = new ZoomAnimation(0.1, TimeSpan.FromSeconds(2), RateFunctions.AccelerateDecelerate);

            _map!.Engine.EnqueueAnimation(new CombinedAnimation(new DeferredAnimation(zoom, TimeSpan.FromSeconds(3)), pan));
        }
        else
        {
            _map!.Engine.Zoom = Tile.GetZoomScale(9);
            _map!.Engine.Center = centerLoc;
        }
    }

    void AddRouteLayer(double lat, double lon)
    {
        _map!.Engine.RemoveLayers<RouteLayer>();

        RouteLayer routeLayer = new();

        routeLayer.Route.AddWaypoint(lat - 1.0, lon - 1.0);
        routeLayer.Route.AddWaypoint(lat - 0.75, lon - 0.75);
        routeLayer.Route.AddWaypoint(lat - 0.75, lon - 0.5);
        routeLayer.Route.AddWaypoint(lat - 0.5, lon - 0.75);
        routeLayer.Route.AddWaypoint(lat - 0.25, lon - 0.5);
        routeLayer.Route.AddWaypoint(lat - 0.5, lon - 0.25);
        routeLayer.Route.AddWaypoint(lat - 0.25, lon - 0.25);
        routeLayer.Route.AddWaypoint(lat - 0.25, lon + 0.25);
        routeLayer.Route.AddWaypoint(lat, lon);

        _map!.Engine.AddLayer(routeLayer);
    }

    void AnimateAlongRoute()
    {
        RouteLayer? existingRouteLayer = _map!.Engine.GetLayers<RouteLayer>().FirstOrDefault();
        if (existingRouteLayer is null)
        {
            return;
        }

        TimeSpan timeBetweenPoints = TimeSpan.FromSeconds(3);
        TimeSpan rotationDuration = TimeSpan.FromSeconds(1.5);

        Route route = existingRouteLayer.Route;
        for (int i = 1; i < route.WaypointCount; i++)
        {
            Waypoint fromWaypoint = route[i - 1];
            Waypoint toWaypoint = route[i];

            double bearingDegrees = Location.InitialBearingDegrees(fromWaypoint.Location, toWaypoint.Location);

            if (i == 1)
            {
                _map!.Engine.EnqueueAnimation(
                    new CombinedAnimation(
                        new ZoomAnimation(Tile.GetZoomScale(11), timeBetweenPoints, RateFunctions.Linear),
                        new PanToLocationAnimation(fromWaypoint.Location, timeBetweenPoints, RateFunctions.AccelerateDecelerate),
                        new RotationAnimation(timeBetweenPoints, (float)bearingDegrees, RateFunctions.AccelerateDecelerate)));
            }
            else
            {
                _map!.Engine.EnqueueAnimation(
                    new CombinedAnimation(
                        new PanToLocationAnimation(fromWaypoint.Location, timeBetweenPoints, RateFunctions.AccelerateDecelerate),
                        new DeferredAnimation(new RotationAnimation(rotationDuration, (float)bearingDegrees, RateFunctions.AccelerateDecelerate), timeBetweenPoints - rotationDuration)));
            }

            if (i == route.WaypointCount - 1)
            {
                _map!.Engine.EnqueueAnimation(new PanToLocationAnimation(toWaypoint.Location, timeBetweenPoints, RateFunctions.AccelerateDecelerate));
            }
        }
    }

    string? _rotationDegreesStr;

    void Rotate()
    {
        if (!float.TryParse(_rotationDegreesStr, out float rotation))
        {
            return;
        }

        _map!.Engine.EnqueueAnimation(new RotationAnimation(TimeSpan.FromSeconds(2), rotation, RateFunctions.AccelerateDecelerate));
    }

    void ClearRoute()
    {
        _map!.Engine.GetLayers<RouteLayer>().FirstOrDefault()?.Route.Clear();
    }

    void NorthToTop()
    {
        _map!.Engine.EnqueueAnimation(new RotationAnimation(TimeSpan.FromSeconds(1), 0, RateFunctions.AccelerateDecelerate));
    }
}
